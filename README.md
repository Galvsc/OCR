# Optical Character Regognition Application

## System Architecture Diagram

![image](https://github.com/user-attachments/assets/5bca6963-f6ae-407b-a8bf-4deb9381a599)

  The diagram above represents the deployed Optical Character Recognition (OCR) program. NestJS framework has been used as the backend REST API, which makes requests for the Prisma Database, S3 Bucket and Tesseract OCR. The requests are made based on the NextJS framework frontend interactions with the user.

  NestJS receives an uploaded image (via POST ‘/ocr/upload’), then it is sent to Tesseract which returns the recognized text. The information about the file (user ID, file name, text) is stored in a Prisma ORM Database, which has been created using the Neon website, and an ID is attributed to the file. The image itself is stored in an AWS S3 bucket database. After the file upload and text recognition, the API returns the extracted text.

  The user information (ID) is necessary to store and fetch the file information in ORM Database. That information is stored in cookies, which are generated by a login POST (‘/login’) request to NestJS, that access the same ORM Database to validate the username and password. The API also allows sign up requests (‘/login/signup’), creating a new user and storing in the database. For each file information fetch, there is an authentication route that requires a token, which is generated and stored in a cookie during login. The GET requests available for a file can provide one of the following returns: 

‘/ocr/list’: List of all user files information (from Prisma DB)

‘/ocr/text’: Extracted text, given the file and user ID (got from Prisma DB)

‘/ocr/download’: PDF file containing the image (got from S3) and the extracted text (got from Prisma DB)
	Given the API endpoint, the requests are made by a NextJS interface that contains a page for login, one for signup and another to manage the user files. The user can upload an image for text recognition, see the text from an uploaded file or download the PDF with the aggregated information (clicking on the file name). 

## Login Page
![image](https://github.com/user-attachments/assets/eebe1f24-b8a7-47e4-9029-0a975ce3de79)

## Sign Up Page
![image](https://github.com/user-attachments/assets/083b96f5-c4e8-49ec-89a6-40b872b699be)

## User Space
![image](https://github.com/user-attachments/assets/96b3c67c-e22a-41a1-ae1d-d380b8572fc6)

## Resources and deployment
	
The resources being used are: Vercel site for NextJS deployment, Railway for NesjtJS host, AWS S3 and Neon Postgres for storing the databases. The databases are connected to the API through keys and configuration variables that are in the NestJS environment in an .env file that must be in the root of backend code. Also an Jwt arbitrary key is in the .env for token generation and authentication. These are the environment variables:

DATABASE_URL (Prisma ORM)

JWT_SECRET (Tokenization)

AWS_ACCESS_KEY_ID

AWS_SECRET_ACCESS_KEY

AWS_S3_REGION

AWS_S3_BUCKET

Also, the NextJS has an .env file in its root directory containing the variable NEXT_PUBLIC_API_path, which is given by the Railway deploy of NestJS.

To run the application, the backend code must contain all the variables cited before for created databases on AWS S3 and on Prisma, the same for the URL for the frontend endpoint API, these variables must be declared in a .env file. The code stored in ocr_backend can be runned on a Railway server or any similar service that allows deployment of the backend code, like AWS instances. To deploy the frontend the ocr_frontend code can be deployed in the Vercel platform. 

The program can be runned locally using the command “npm run dev” in the root of ocr_frontend in the terminal and “npm run start:dev” in the ocr_backend. In this case the API endpoint and link to access the Next site will be localhost ports.
